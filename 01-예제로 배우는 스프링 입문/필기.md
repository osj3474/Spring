# 목차

- 프로젝트 설정
- application.propertiest
- IoC
- IoC 컨테이너
- Bean
- DI
- 메모





<br />

# 프로젝트 설정

동물병원 예제인 spring-petclinic 사용할 예정이다.

1. https://github.com/spring-projects/spring-petclinic 에서 git clone 받아서 프로젝트를 생성한다.

2. 빌드 후 실행한다.

   ```
   ./mvnw package
   java -jar target/*.jar
   ```

   - maven의 package빌드를 실행하면, '프로젝트를 빌드해서, (기본적으로) jar파일을 만든다.'

     (pom.xml의 \<packaging> 태그로 지정해둔 것이 없으면 기본적으로 jar 프로젝트임.)

   - java -jar 는 jar파일을 실행하는 명령어이다.

   cf) 한번만 maven packaging해주면, 그 뒤로는 main method실행해도 어플리케이션이 실행된다.

<br />

cf) 디버그 모드 실행이란? 

1. break point를 잡고, DEBUG모드로 실행하면, 해당 포인트에서 멈춘다.

2. F8를 눌러서 한 줄씩 실행해보자. (intellij 기준 단축키)







<br />

# application.properties

: 어플리케이션 설정 파일이다.

### [ 로그 ]

**스프링 부트** 프로젝트의 경우, **application.properties**의 `loggin.level.org.springframework` 로 **로그 레벨** 결정할 수 있다.

로그 레벨은 5단계가 있다.

- ERROR
- WARN
- INFO
- DEBUG
- TRACE

아래 설정으로 갈수록 더 상세한 로그가 남게 된다. 로그 레벨은 **패키지 단위로 설정**할 수 있다.

```properties
loggin.level.org.springframework.web=DEBUG
```



<br />

### [ DB ]

**데이터 베이스, 스키마, 데이터** 모두 여기서 설정할 수 있다.

```properties
# database init, supports mysql too
database=h2
spring.datasource.schema=classpath*:db/${database}/schema.sql
spring.datasource.data=classpath*:db/${database}/data.sql
```







<br />

# IoC

 : inverse of control의 약자로, (의존성에 대한) 제어권의 역전이라고 한다.



```
프로그램의 제어 흐름을 직접 제어하는 것이 아니라, 외부에서 제어의 흐름을 가지는 것을 IoC(제어의 역전) 라고 한다. 
```

*Source : 김영한 님의 설명*



가령, 일반적인 경우에는 자기가 사용할 의

Spring이 Bean이라는 객체를 관리하는데, 의존성도 관리해준다. 가령, Repository를 Bean으로 등록해놓으면, Controller가 생성될 때, Repository를 인자로 받아서 생성이 되는데, 





cf) https://martinfowler.com/articles/injection.html 에 자세히 나와있음.



<br />

# IoC 컨테이너

 : Bean을 만들고, Bean들 사이의 의존성을 엮어주고, 그렇게 만들어져 있는 Bean들을 제공하는 것.

(의존성 주입은 기본적으로 IoC컨테이너가 관리하는 Bean끼리만 가능하다.)

ex) 

- ApplicationContext (BeanFactory를 상속받고 있음)
- BeanFactory

### 



<br />

# Bean

 : IoC 컨테이너가 관리하는 객체이다.

<br />

### [ 등록 ]

직접만든 객체는 Bean이 아니다. Bean으로 등록해줘야 한다.

#### 1. Component Scanning

: ComponentScan이 @Component가 있으면 Bean으로 등록해준다.

ex) @Controller, @Service, @Repository, @Configuration 은 @Component를 상속받고 있어서 Bean이 된다.

<br />

#### 2. 특정한 Interface를 상속받은 경우

: Repository는 Spring Data JPA가 제공해주는 기능에 의해서 Bean으로 등록이 된다. 

```java
public interface SampleRepository extends Repository<Sample, Integer>
```

<br />

#### 3. 직접 등록

: @Configuration 밑에, Bean으로 등록하고자 하는 클래스를 반환하는 메서드에 @Bean를 붙인다. (@Configuration도 @Component를 상속받기 때문에, 여기로 와서 @Bean을 보고 등록을 해준다.)

```java
@Configuration
public class SampleConfig {
  
  @Bean
  public SampleController sampleController(){
    return new SampleController();
  }
}
```





cf) (intellij 기준) Bean으로 등록되었는지 확인

: 클래스 왼쪽에 녹색 콩 아이콘을 보고 알 수 있다.





<br />

### [ 사용 ]

#### 1. IoC 컨테이너(ApplicationContext) 이용하기

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class SampleContorllerTest {
  @Autowired
  ApplicationContext applicationContext;
  
  @Test
  public void testDI(){
    SampleController bean = applicationContext.getBean(SampleController.class);
    assertThat(bean).isNotNull();
  }
}
```



<br />

#### 2. @Autowired 이용하기

```java
@Autowired
private OwnerRepository owners;
```







<br />

# DI

 : dependency injection의 약자로, 

어플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 DI라고 한다.



메모리 저장소로 할지, JDBC로 할지









<br />

# 메모

1. build툴 비교하기

   - maven : 
   - gradle : 

2. 프레임워크 vs 라이브러리

   - 프레임워크 : 내가 작성한 코드를 제어하고 대신 실행해주는 것

     ex) JUnit이라는 프레임워크가 @BeforeEach를 먼저 실행하고, @Test를 실행해주는 것

   - 라이브러리 : 내가 작성한 코드를 내가 직접 호출하고 실행하는 것

     ex) csv를 json으로 바꾸는 함수를 가져와서 쓰는 것