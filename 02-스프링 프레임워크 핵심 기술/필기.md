# 목차

1. [IoC 컨테이너](#1-ioc-컨테이너-)
<br /></t>
   1.1 [ApplicationContext](#1-1-applicationcontext-)
<br /></t>
   1.2 [Autowired](#1-2-autowired-)
<br /></t>
   1.3 [ComponentScan](#1-3-componentscan-)
<br /></t>
   1.4 [Bean 스코프](#1-4-bean-스코프-)
<br /></t>
   1.5 [Environment](#1-5-environment-)
2. 리소스
3. Validation
4. 데이터 바인딩
5. SpEL
6. 스프링 AOP
7. Null-Safety





<br /><br />

--------------------------------------------------------------------------

# 1. IoC 컨테이너 [👆](#목차)

## 정의

### 1) IoC 

 : 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법이다.

쉽게 말하면,

```java
private BookRepository bookRepository;
```

이렇게만 선언하면 null일텐데, 스프링이 `bookRepository` 에 대한 정보를 주입을 해줘서 바로 사용을 할 수 있다.



<br />

### 2) IoC 컨테이너 

 : Bean들을 가지고 IoC 기능을 제공하는 컨테이너이다.

ex)

- BeanFactory : IoC컨테이너 최상위 인터페이스이다.
- ApplicationContext : BeanFactory를 상속받은 IoC컨테이너로, 가장 많이 사용한다.



<br />

### 3) Bean

 : **IoC 컨테이너에 의해 관리되는 객체**이다.

#### 장점

1. IoC컨테이너에 의해 **의존성 관리**가 된다.

2. IoC컨테이너에 등록된 Bean은 기본적으로 **싱글톤**으로 등록되어 싱글톤으로 사용하려고 할 때, 편하다.

   cf) 스코프

   - 싱글톤 : 하나만 만들어서 전체에 사용하는것
   - 프로토타입 : 매번 다른 객체

3. **라이프 사이클 인터페이스** 로 부가적인 작업을 할 수 있다.

   (Bean에 등록되면서 호출되는 메서드들을 이용하는 경우를 말한다.)



<br /><br />

--------------------------------------------------------------------------

# 1-1. ApplicationContext [👆](#목차)

### 1) (고전적인) Bean 등록 방법

: 스프링 IoC 컨테이너는 빈설정(xml) 파일이 있어야한다. 가령, `BookService` 가 `BookRepository` 를 주입받는다고 해보자.

```java
public class BookService{
   BookRepository bookRepository;

   public void setBookRepository(BookRepository bookRepository){
      this.bookRepository = bookRepository;
   }
}
```

이를 위해서는, 다음과 같이 일일이 Bean으로 등록을 해줘야 했다.

**application.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  	<!-- 여기부터 -->
    <bean id="bookRepository"
        class="com.example.demo.BookRepository">
    </bean>
    
    <bean id="bookService"
        class="com.example.demo.BookService">
        <property name="bookRepository" ref="bookRepository" />
    </bean>
  	<!-- 여기까지 주목 -->
  
</beans>
```

<br />
이런 불편함을 해결하는 방법이 Component Scan으로 간편하게 빈을 등록하는 것이다.

**application.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

   <!-- 여기부터 -->
    <context:component-scan base-package="com.example.demo" />
   <!-- 여기까지 주목 -->
</beans>
```

위처럼 해주면,
 - Bean 등록 : @Component, @Service, @Repository, @Configuration+@Bean 조합 등
 - 의존성 주입 : @Autowired, 생성자, setter 등

cf) 참고로, @SpringBookApplication 어노테이션에 @ComponentScan이 있다.



<br /><br />

--------------------------------------------------------------------------

# 1-2. @Autowired [👆](#목차)

### **1) 사용할 수 있는 위치**
 - 생성자 (스프링 4.3부터는 생략 가능)
 - 세터
 - 필드

 cf) @Autowired(required = false) 라는 옵션을 주면, 의존성 주입 없이도 생성이 되게 할 수 있다.

<br />

### **2) Bean이 여러개인 경우, 처리 방법**

<br />

*BookRepository.java*

```java
public interface BookRepository{

}
```

*FirstBookRepository.java*
```java
@Repository
public class FirstBookRepository implements BookRepository{

}
```

*SecondBookRepository.java*

```java
@Repository
public class SecondBookRepository implements BookRepository{

}
```

<br />

이렇게 되면, BookRepository타입의 Bean이 2개가 생겼는데, 다음과 같이 BookRepository를 주입받으려고 하면, 다음의 상황에서 FirstBookRepository 와 SecondBookRepository 중에 어떤 Repository를 주입받을까?

<br />

*BookService.java*
```java
@Service
public class BookService{
   @Autowired
   BookRepository bookRepository;
}
```

<br />

### **2-1) 결과**

 : 에러가 난다.

<br />

### **2-2) 해결 방법**

**1. @Primary 이용** (추천)
<br />

 : Bean들 중 가장 우선순위를 높여서 다른 곳에서 주입하려고 할 때, @Primary 어노테이션이 있는 Bean을 주입받도록 한다.

 ```java
@Repository @Primary
public class FirstBookRepository implements BookRepository{

}
 ```
<br />

**2. @Qualifier 이용**
<br />

 : 어떤 Bean을 주입받을 지를 명시한다.

 ```java
@Service
public class BookService{
   @Autowired @Qualifier("FirstBookRepository")
   BookRepository bookRepository;
}
 ```

<br />

**3. 여러 Bean들 모두 주입**
<br />

 : List 타입으로 여러 Bean들을 모두 주입받도록 한다.

```java
@Service
public class BookService{
   @Autowired
   List<BookRepository> bookRepositories;  // FristBookRepository, SecondBookRepsitory
}
```

<br />

**4. 트릭** (비추천)
<br />

 : 필드명을 주입받고 싶은 Bean 이름으로 한다. (첫글자 소문자, 그 외 동일하게)

 ```java
@Service
public class BookService{
   @Autowired
   BookRepository firstBookRepository;
}
 ```


 <br /><br />

--------------------------------------------------------------------------

# 1-3. @ComponentScan [👆](#목차)

### **1) 스캔 동작**

 - @ComponentScan 어노테이션이 있는 곳부터 스캔이 시작된다. 
 - @SpringBootApplication이 @ComponentScan을 담고 있다.
 - @SpringBootApplication이 있는 패키지 안에 있는 것들만 스캔이 가능하다.
 - @Component 어노테이션이 있는 것들을 스캔한다.
 - @Filter로 스캔할 컴포넌트를 필터링할 수 있다.


<br />

### **2) 다른 패키지, Bean 등록**

: 다음은 다른 패키지에 있는 컴포넌트를 Bean에 등록하는 방법 중 하나이다.

```java
@SpringBootApplication
public class DemoApplication {

   @Autowired
   OtherPack otherPack;  // 다른 패키지라 intellij가 에러로 인식. (하지만, 실행 시 error없음.)

	public static void main(String[] args) {
		var app = new SpringApplication(DemoApplication.class);
		app.addInitializers(new ApplicationContextInitializer<GenericApplicationContext>() {
			@Override
			public void initialize(GenericApplicationContext ctx) {
				ctx.registerBean(OtherPack.class);   // 다른 패키지 클래스를 Bean 등록
			}
		});
		app.run(args);
	}
}
```


<br />

### **3) @Component**

: 아래의 어노테이션은 모두 @Component를 가지고 있다.
<br />
- @Repository
- @Service
- @Controller
- @Configuration
<br />


cf) 싱글톤 스코프인 Bean은 초기에 다 생성을 한다. (이런 Bean이 많으면, 초기 구동시간이 조금 걸릴 수 있다.)



<br /><br />

--------------------------------------------------------------------------

# 1-4. Bean 스코프 [👆](#목차)

### **1) 싱글톤**

 - 어플리케이션 전역에 걸쳐서 해당 Bean의 인스턴스가 하나이다.
 - 기본 스코프가 싱글톤이다. (사실 대부분의 경우, 싱글톤을 쓸 것임.)




<details>
   <summary> 예시 소스코드 </summary>
<br />

*Single.java*
```java
@Component
public class Single {
    @Autowired
    Proto proto;

    public Proto callProto(){
        return proto;
    }
}
```

*Proto.java*
```java
@Component
public class Proto {
}
```

*ScopeRunner.java*
``` java
@Component
public class ScopeRunner implements ApplicationRunner {

    @Autowired
    Single single;

    @Autowired
    Proto proto;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(proto);               // Proto@9cd25ff
        System.out.println(single.callProto());  // Proto@9cd25ff
    }
}
```

<br />

=> 결과를 보면, Runner가 주입받은 Proto라는 객체와, Single이 주입받은 Proto라는 객체가 완전히 일치함을 알 수 있다.
</details>




<br /><br />

### **2) 프로토타입**

 - 매번 새로운 인스턴스를 만들어서 사용하는 것. 
 - Bean을 받아올 때만, 새로운 인스턴스가 된다.



<details>
   <summary> 예시 소스코드 </summary>
<br />


*Proto.java*
 ```java
@Component @Scope("prototype")
public class Proto{

}
 ```


*ScopeRunner.java*
```java
@Component
public class ScopeRunner implements ApplicationRunner {

    @Autowired
    ApplicationContext ctx;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("Proto");
        System.out.println(ctx.getBean(Proto.class)); // Proto@780ec4a5
        System.out.println(ctx.getBean(Proto.class)); // Proto@e24ddd0
        System.out.println(ctx.getBean(Proto.class)); // Proto@6f70f32f

        System.out.println("Single");
        System.out.println(ctx.getBean(Single.class)); // Single@548e76f1
        System.out.println(ctx.getBean(Single.class)); // Single@548e76f1
        System.out.println(ctx.getBean(Single.class)); // Single@548e76f1
    }
}
```

<br />

=> 결과를 보면, Bean을 가지고 올때마다, 프로토 타입의 Bean의 경우, 새로운 인스턴스로 반환되는 것을 볼 수 있다.

</details>



<br /><br />

### **3) 프로토타입 주의 사항**
<br />

**[문제]** 싱글톤 안에서 프로토타입 Bean을 사용하는 경우에는, 원래 의도한 프로토타입으로 동작하지 않는다.

<details>
   <summary> 예시 소스코드 </summary>
<br />

*Single.java*
```java
@Component
public class Single {
    @Autowired
    Proto proto;

    public Proto callProto(){
        return proto;
    }
}
```

*ScopeRunner.java*
```java
@Component
public class ScopeRunner implements ApplicationRunner {

    @Autowired
    ApplicationContext ctx;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("Proto by Single");
        System.out.println(ctx.getBean(Single.class).callProto()); // Proto@61a002b1
        System.out.println(ctx.getBean(Single.class).callProto()); // Proto@61a002b1
        System.out.println(ctx.getBean(Single.class).callProto()); // Proto@61a002b1
    }
}
```

</details>

<br /><br />

**[해결]** 프로토타입 Bean을 직접 참조하는 것이 아니라, Proxy를 통해서 참조하도록 하면 된다.

<details>
   <summary> 예시 소스코드 </summary>
<br />

*Proto.java*

```java
@Component @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class Proto {
}
```

*ScopeRunner.java*
```java
@Component
public class ScopeRunner implements ApplicationRunner {

    @Autowired
    ApplicationContext ctx;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("Proto by Single");
        System.out.println(ctx.getBean(Single.class).callProto()); // Proto@5bd1ceca
        System.out.println(ctx.getBean(Single.class).callProto()); // Proto@30c31dd7
        System.out.println(ctx.getBean(Single.class).callProto()); // Proto@499b2a5c
    }
}

```
</details>

<br />

cf) 참고 : https://en.wikipedia.org/wiki/Proxy_pattern



<br /><br />

--------------------------------------------------------------------------

# 1-5. Environment [👆](#목차)

### 1) 
















<br /><br /><br />

# 메모

1. mock 객체

   : 테스트 코드를 작성할 때, **의존성 문제**로 특정 객체를 생성하는데 어려운 경우 만드는 가짜 객체이다.

   [사용법]

   - mock객체를 만든다. 
     - mock() 함수 이용
     - @Mock이용
   - when(A).thenReturn(B); 

   [예시]

   ```java
   @Mock
   BookRepository bookRepository; // cal메소드 : 10을 반환하는 메소드
   
   @Test
   public void calTest(){
     when(bookRepository.cal()).thenReturn(10);
   }
   ```

   


